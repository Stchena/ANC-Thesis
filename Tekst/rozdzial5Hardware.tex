\chapter{Hardware -- konfiguracja}
Ten rozdział poświęcony jest dokładnemu opisowi konfiguracji układu i~jego peryferiów oraz procesu generowania kodu w~C. Autor wyszczególnia kluczowe decyzje konfiguracyjne i~uzasadnia podjęte wybory. Autor przytacza fragmenty dokumentacji płytki ewaluacyjnej, instrukcji obsługi użytkownika oraz innych dokumentów dostarczonych przez producenta mikrokontrolera, aby poprzeć wywody i~obliczenia obecne w~tym rozdziale. Całość procesu dobierania parametrów i~ustawień komponentów płytki ewaluacyjnej przeprowadzona jest we wspomnianym w~sekcji \ref{sec:IDE} środowisku STM32CubeMX. Zastosowano podejście bare-metal programming, by w~jak największym stopniu ograniczyć narzuty czasowe operacji niezwiązanych ściśle z~przetwarzaniem dźwięku.
\section{Obliczeniowa platforma sprzętowa}
Jak już opisano wcześniej, do realizacji projektu autor wybrał mikrokontroler na płytce ewaluacyjnej NUCLEO-STM32F446RE. Płytka posiada 64 piny GPIO do zastosowania na różnorodne sposoby -- do komunikacji ze światem zewnętrznym. Centralnym elementem płytki jest mikrokontroler z~procesorem ARM Cortex M4 w~architekturze 32-bit RISC\footnote{Przetwarzanie Danych przez Ograniczoną Listę Rozkazów (ang. Reduced Instruction Set Computing)}. Mikroprocesor pracuje z~częstotliwością zegara równą \SI{180}{\MHz} i~posiada 512KB pamięci flash oraz 128KB pamięci cache\footnote{Pamięć podręczna SRAM, pozwala na bezpośredni zapis i~odczyt danych wewnątrz rejestrów procesora bez oczekiwania na dane}.
\section{Konfiguracja peryferiów}
Konfigurację systemu należy rozpocząć od uruchomienia wszystkich wymienionych w~poprzednim rozdziale elementów cyfrowych. Dobór parametrów omówiony zostanie zatem po kolei dla każdego komponentu:
\begin{itemize}
	\item Przetwornik analogowo-cyfrowy nr 1 (od głównego mikrofonu)\\
	Oba przetworniki skonfigurowane są w~trybie dualnym jednoczesnej konwersji zwykłej\footnote{Ang. Dual regular simultaneous mode}. Pozwala to na synchronizowane działanie komponentów z~przetwornikiem numer~1~jako elementem nadrzędnym. Przetwarzany sygnał kierowany jest do kanału~0. Częstotliwość pracy przetworników uzależniona jest od napięcia zasilania, co oznacza, że przy dostarczonym napięciu \SI{3.3}{\V} komponenty pracują z~częstotliwością w~przybliżeniu równą \SI{30}{\MHz}. Konwersja wywoływana jest przez wewnętrzny timer odmierzający interwał czasowy równy %TODO napisać ile to w końcu będzie równe
	aby zapewnić stały krok próbkowania. Oprócz tego własny timer przetwornika jest skalowany 8-krotnie, aby spowolnić jego działanie i~przez to zwiększyć dokładność pomiaru. Czas próbkowania ustawiony jest na 480~cykli, co w~połączeniu ze stałym czasem doliczonym, równym 12 cykli\cite{RM0390} daje 492 cykle składające się na pojedynczą konwersję sygnału. Oznacza to, że przy wspomnianej wcześniej częstotliwości pracy, jedna konwersja zajmować będzie w~przybliżeniu:
		
\begin{center}
		$ t_{przetwarzania} = \frac{preskaler * (t_{probkowania} + t_{doliczony})}{f_{pracy\_adc}} = \frac{8*(480+12)}{\SI{30}{\MHz}} = \SI{131,2}{\micro\s} $
	
	$ f_{przetwarzania} = \frac{1}{t_{przetwarzania}} = \frac{1}{\SI{0.0001312}{\s}} \approx \SI{7622}{\Hz} $ 
	
\end{center}
	W~związku z~tym, przetwornik w~takiej konfiguracji będzie mógł efektywnie konwertować sygnały o~maksymalnej częstotliwości równej \SI{3811}{\Hz}. Należy jednak wziąć pod uwagę czas, jaki zajmą obliczenia generujące sygnał przeciwstawny, częstotliwość wzbudzeń pochodzących od timera oraz czas konwersji DAC. Wszystkie te oraz inne czynniki składają się na zmniejszenie efektywnej zdolności przetwarzania układu. Autor po opisaniu wszystkich parametrów konfiguracyjnych oraz zaimplementowaniu i~przetestowaniu programu przedstawi maksymalną częstotliwość, jaką układ jest w~stanie przetwarzać.
	\item Przetwornik analogowo-cyfrowy nr 2 (od mikrofonu odsłuchowego)\\
	Ten przetwornik jest podrzędny względem pierwszego, co oznacza, że synchronizuje się z~nim i~dostosowuje swoje działanie do wspólnego transferu danych poprzez DMA w~trybie~2. W~tym przetworniku sygnał kierowany jest do kanału~1.
	\item Przetwornik cyfrowo-analogowy\\
	Ten komponent, w~przeciwieństwie do poprzedniego, nie ma dużo opcji konfiguracyjnych. Wybrano tutaj transfer jednokanałowy, gdyż układ emitował będzie sygnał monofoniczny. Gdyby układ miał spełniać funkcję słuchawek stereo z~dwoma kanałami, można byłoby wtedy otworzyć drugi kanał tego przetwornika. Ponieważ nie wybrano żadnego trybu wyzwalacza, konwersja następuje automatycznie po upłynięciu jednego cyklu zegara APB1 (o~częstotliwości \SI{84}{\MHz}) od momentu wpisania nowej wartości do odpowiedniego rejestru.
	\item Kontroler DMA\\
	Ten element jest konieczny do prawidłowego funkcjonowania przetworników ADC w~trybie dualnym. Gdy przetworniki skończą konwersję, 12-bitowe wyniki tego działania zapisywane są do zmiennych 16-bitowych, które następnie łączone są w~jedną zmienną 32-bitową (bity wyników zapisywane są w~tej zmiennej w~kolejności ADC2\_ADC1). Taka pojedyncza zmienna 32-bitowa jest następnie transferowana przez kontroler DMA do pamięci urządzenia, gdzie należy wyłuskać pojedyncze wyniki konwersji. Jest to charakterystyczne zachowanie kontrolera DMA w~trybie~2,~który jest automatycznym trybem pracy przy dwóch przetwornikach z~jednoczesną konwersją.
	\item PLACEHOLDER
\end{itemize}
\section{Wygenerowanie kodu w języku C}
\label{sec:configGenerate}
Ustawienia zapamiętywane są w~pliku o~formacie .ioc, który okazuje się być zapisem tekstowym poszczególnych ustawień wraz z~przypisaniem wartości i~trybów. Plik ten jest interpretowany przez STM32CubeMX i~na jego podstawie generowana jest konfiguracja (wraz z~ukazującym ją interfejsem graficznym). Po przeprowadzeniu konfiguracji układu oraz sprawdzeniu ustawień zegarów i~liczników mikrokontrolera, można przystąpić do wygenerowania kodu konfiguracyjnego w~języku~C. Program użyty do konfiguracji pozwala na wygenerowanie współpracującego z~biblioteką HAL (użytą przez autora do zaimplementowania całości programu) kodu podzielonego na fragmenty automatycznie generowane oraz sekcje użytkownika. Jest to o~tyle istotne, że w~przypadku wystąpienia potrzeby zmiany konfiguracji któregoś komponentu, ponowne wygenerowanie kodu konfiguracyjnego nie ingeruje w~specjalne sekcje użytkownika. Pozwala to jeszcze sprawniej prototypować układy bez obawy o~utratę wypracowanych efektów. Poza wspomnianą funkcjonalnością, STM32CubeMX wspiera również generowanie kodu w~konwencjach specyficznych dla poszczególnych środowisk programistycznych -- można wybrać jedno z~nich z~listy dostępnej w~zakładce "Project~Manager". Autor wybrał środowisko SW4STM32, czyli wspomniany w~rozdziale 3 i~użyty w~implementacji "System Workbench for STM32". Moduł generowania kodu dostarcza jeszcze kilku zaawansowanych narzędzi i~ustawień, jednak autor nie zmieniał ich automatycznie dobranych parametrów.