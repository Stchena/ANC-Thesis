\chapter{Analiza możliwych rozwiązań}
\label{cha:możliwe_układy}
 W~poprzednim rozdziale autor pokazał możliwe struktury układu tłumienia hałasu -- pasywny lub aktywny. W~tym rozdziale, autor wybiera konstrukcję hybrydową (pasywno-aktywną) feedforward-feedback oraz przedstawi możliwe do zastosowania platformy sprzętowe. Na podstawie analizy słabych i~mocnych stron wymienionych podejść, dokonany zostanie dalszy wybór.

 Zasada konstrukcyjna systemu aktywnego tłumienia hałasu w~żadnym kroku nie specyfikuje układu elektronicznego, na którym można zaimplementować algorytm tłumienia. Oznacza to zatem, że jeżeli konstruktor zastosuje się do praw fizyki i~wymagań projektu, to powinien być w~stanie zaimplementować cały system na dowolnym układzie -- analogowym lub cyfrowym. W~następnych sekcjach autor postara się odpowiedzieć na pytanie -- który z~nich najlepiej wybrać, a~jeśli cyfrowy, to jaka platforma sprzętowa jest najlepsza? 
\section{Układ analogowy}
\label{sec:analog}
Układ analogowy jest najtańszy i~najszybszy -- bazuje na wzmacniaczach operacyjnych odwracających i~odpowiednim wysterowaniu fazy sygnału. Daje możliwość osiągnięcia wysokich zakresów częstotliwościowych oraz charakteryzuje się bardzo niskim poborem prądu -- co sprzyja dobrej praktyce projektowania układów tanich w~zasilaniu, co ma szczególne znaczenie przy zasilaniu bateryjnym. Pojawiają się jednak problemy przy implementowaniu pętli automatyki adaptacyjnego filtru -- złożoność układu znacznie wzrasta, trudno jest też poprawić taki system, jeśli gdzieś popełniono błąd. W~zasadzie nie da się takiego rozwiązania zaprojektować inkrementacyjnie -- należy opracować od razu cały, kompletny system, gdyż zmiany w~trakcie konstruowania wymagają zbudowania całości od nowa. Choć rozwiązanie jest mniej kosztowne i szybsze od innych, jest też zadziwiająco nieelastyczne, a~przy wzrastającej złożoności filtra komplikuje się jego konstrukcja.
\section{Układ cyfrowy}
\label{sec:digital}
Zastosowanie cyfrowego układu jest droższe i~wydaje się nieco trudniejsze, jednak zwiększa możliwości konstrukcyjne. Do wyboru jest kilka platform, bardzo często integrujących w~sobie sporo funkcjonalności, które w~podejściu tworzenia analogowego układu należałoby samodzielnie stworzyć (zakładając oczywiście, że technika analogowa na to pozwoli).  Pomimo początkowego zwiększenia złożoności układu, okazuje się, że w~dłuższej perspektywie czasowej ułatwione jest prototypowanie i~programowanie układu, ponieważ istnieje mnogość narzędzi inżynierskich pomagających w~procesie pracy z~układami cyfrowymi. Można nawet powiedzieć, że ucyfrowienie platformy realizującej tłumienie hałasu daje szansę na zaimplementowanie wymiennych algorytmów, filtrów i~dodanie kilku funkcjonalności, czyli uczynienie systemu modułowym i~przystosowanym do różnych zastosowań. Taka jest zresztą zasada działania kart dźwiękowych, które posiadają zaawansowane silniki efektów, swobodnie dodawane, usuwane i~modyfikowane. W~odróżnieniu od ścieżki analogowej, układ taki jest też zdecydowanie mniej podatny na szumy i~przesłuchy sieci ze względu na charakter przesyłanego sygnału. Następne sekcje przybliżą przykłady platform, które pozwoliłyby na realizację układu aktywnego tłumienia hałasu.
\subsection{Mikrokontroler}
\label{uC}
Odpowiednio złożonym, a~jednocześnie niezbyt skomplikowanym układem jest mikrokontroler.\\
Jedną z~najbardziej popularnych obecnie grup mikrokontrolerów jest rodzina urządzeń STM32, bazujących na mikroprocesorach ARM~Cortex-M4. Warto nadmienić, że firma STMicroelectronics posiada w~asortymencie zarówno same mikrokontrolery, jak i~płytki prototypowe z~zamontowanymi gotowymi peryferiami. Ta platforma udostępnia dwa możliwe sposoby programowania:
\begin{itemize}
	\item bare-metal programming -- czyli programowanie czystego sprzętu na zasadzie proceduralnej bez zainstalowanego systemu operacyjnego,
	\item RTOS\footnote{System operacyjny czasu rzeczywistego (ang. Real-Time Operating System)} -- czyli instalacja i~obsługa odwołań systemu posiadającego jądro czasu rzeczywistego i~wspierającego tego typu zastosowania.
\end{itemize}
Ponieważ projekt nie wymaga posiadania systemu operacyjnego, rozważa się tutaj tylko podejście baremetal programming. Twórcy opisywanej platformy regularnie dostarczają nowych płytek prototypowych, narzędzi, programów oraz bibliotek programistycznych, co sprawnie tworzy spójny ekosystem ułatwiający pracę.
\subsection{Mikrokomputer jednopłytkowy}
\label{mikrokomp}
Taka platforma jest o~jeden krok bardziej zaawansowana od mikrokontrolera -- zazwyczaj zawiera wiele układów peryferyjnych oraz daje możliwość zainstalowania pełnego systemu operacyjnego Linux, Windows i~tym podobnych. Mikrokomputery zazwyczaj posiadają bardziej zaawansowane komponenty, więcej pamięci i~szybsze procesory. Ponieważ mikrokomputery mają zainstalowany system, można dowolnie dobrać środowisko programistyczne, implementować dodatkowe funkcjonalności oraz wykorzystać systemowe wsparcie dla wielowątkowości -- na przykład użyć jednego wątku do algorytmu aktywnego tłumienia hałasu, zaś na drugim zbierać statystyki i~przesyłać je chociażby do pliku lub serwisu sieciowego, by później przetworzyć te dane.

Niestety okazuje się, że narzut czasowy powstały w~wyniku wprowadzenia do projektu systemu operacyjnego jest zbyt duży -- należy w~pierwszej kolejności zwrócić uwagę na fakt, że zwykły system (nierzeczywistego czasu) ma niewywłaszczalne jądro. Oznacza to, że proces który raz zacznie być przetwarzany, musi być dokończony, i~nie da się go przerwać. Z~kolei system, który ma wywłaszczalne jądro, wspiera rozróżnianie priorytetów procesów -- co sprawia, że w~momencie przyjścia przerwania od ''ważniejszego'' procesu, ten o~niższym priorytecie oddaje zasób. Pozwala to, poprzez modyfikację priorytetów w~jądrze systemu, ustawić największe prawa dla sterownika dźwięku.
Autor, pragnąc poprzeć powyższy wywód, przeprowadził prosty test opóźnienia na mikrokomputerze Raspberry~Pi~3B+. Na sprzęcie zainstalowano system operacyjny Raspbian~Lite, bazujący na systemie operacyjnym Linux (dystrybucja Debian), który, choć nie jest systemem czasu rzeczywistego, to dość mocno obniża zużycie zasobów poprzez wyłączenie w~konfiguracji większości daemonów\footnote{daemon -- proces działający w tle, zazwyczaj jest to sterownik sprzętu, na przykład sterownik Bluetooth} i~pozostawienie tylko najpotrzebniejszych (do działania projektu -- a~więc sterowników dźwięku). Do przeprowadzenia testu opóźnienia wykorzystano API sterownika ALSA\footnote{Zaawansowana Architektura Dźwięku dla Linux (ang. Advanced Linux Sound Architecture)}. Wśród przykładowych skryptów (napisanych w~języku C) można znaleźć plik nazwany \textit{latency.c}\footnote{https://www.alsa-project.org/wiki/Test\_latency.c -- stan z~dnia 25.11.2019 godzina 15:00}, który dla kilku podstawowych częstotliwości dźwięku wylicza opóźnienie przesłania sygnału z~wejścia (mikrofonu) bezpośrednio na wyjście (głośnik). Okazało się, że opóźnienia wyniosły TODO. %TODO dopisac ze wykonalem test na raspberry na ALSIE
\\
Jedynym sposobem uniknięcia takich narzutów czasowych jest zastosowanie systemu czasu rzeczywistego, jednak to zredukowałoby charakter platformy sprzętowej o~krok w~tył -- do poziomu mikrokontrolera.
\subsection{Karta dźwiękowa komputera PC}
\label{soundcard}
Podstawowa karta dźwiękowa zawiera cztery główne elementy:
\begin{enumerate}
	\item Wejścia i~wyjścia do komunikacji z~mikrofonami lub głośnikami (i~tym podobnym).
	\item Przetwornik analogowo-cyfrowy (dokonuje konwersji sygnałów wejściowych).
	\item Przetwornik cyfrowo-analogowy (dokonuje konwersji sygnałów wyjściowych).
	\item Interfejs PCI\footnote{Magistrala komunikacyjna (ang. Peripheral Component Interconnect) przyłączająca karty rozszerzające do płyty głównej komputera} lub inny, zazwyczaj używany do komunikacji z~płytą główną komputera, w~którym zainstalowana jest karta.
\end{enumerate}
Większość nowoczesnych kart dźwiękowych zawiera jednak znacznie więcej niż wymienione komponenty, aby zapewnić wsparcie dla zaawansowanych funkcjonalności, takich jak dźwięk stereofoniczny 3D, wsparcie dla MIDI\footnote{Cyfrowy interfejs instrumentów muzycznych (ang. Musical Instrument Digital Interface)}, dodatkowe efekty dźwiękowe i~wiele innych. W~skład takich elementów wchodzą na przykład DSP\footnote{Procesor sygnałowy (ang. Digital Signal Processor)} lub nawet zaawansowane silniki dźwiękowe, dedykowane do~dokonywania przetworzeń dźwięku w~dziedzinie czasu lub częstotliwości (jak na przykład dodanie echa, opóźnienia czasowego, miksowanie efektów lub filtracja). Takie silniki stosowane są na przykład w~kartach dźwiękowych firmy Creative, aby odciążyć procesor ogólnego przeznaczenia i~przyspieszyć konwersje.\\
Z~uwagi na przeznaczenie kart dźwiękowych oraz różnorodność oferowanych przez nie funkcji, wydawać by się mogło, że są one idealnymi kandydatami na platformę sprzętową do układu aktywnego tłumienia hałasu. Tak jednak nie jest ze względu na niedostępność tej platformy -- twórcy kart dźwiękowych raczej nie udostępniają żadnych możliwości ingerowania w~oprogramowanie, zostawiając jedynie możliwość tworzenia sterowników obsługujących efekt działania kart poprzez oficjalne API\footnote{Interfejs programowania aplikacji (ang. Application Programming Interface)}. Oznacza to w~takim razie brak samodzielności tej platformy, czyli uzależnienie jej od innego sprzętu, co nie spełnia wymogów projektu.
\subsection{FPGA}
\label{FPGA}
Bardzo zaawansowana i~wciąż nowa na rynku FPGA\footnote{Bezpośrednio Programowalna Macierz Bramek (ang. Field Programmable Gate Array)} może być odpowiedzią na problemy z~brakiem wielowątkowości poprzednich rozwiązań. Ta platforma wspiera wielozadaniowość na poziomie swojej architektury -- jak wskazuje nazwa, opiera się ona na rozległej macierzy programowalnych bramek logicznych. Twórcy tych platform dostarczają własne środowiska programistyczne, gdzie konstruktorzy i~programiści mogą często w~graficzny sposób konfigurować i~programować układy, co ułatwia nieco pracę z~tym zaawansowanym sprzętem. Wiodącym producentem na rynku jest obecnie Xilinx, które udostępnia narzędzia programistyczne takie jak Vivado. Niestety wraz z~możliwościami sprzętu, w~parze idzie jego koszt. Ponieważ dodatkowo konkurencyjność rynku jest niska, producenci tego sprzętu mają swobodę dyktowania wysokich cen -- co zdecydowanie deklasuje to rozwiązanie w~kontekście tego projektu. Pomijając koszt -- platforma daje zwyczajnie zbyt dużo możliwości, aby można było ją wykorzystywać do projektu opartego na przetwarzaniu potokowym, gdyż byłoby to niedopasowanie platformy do potrzeb projektu.
\section{Wybór rozwiązania}
\label{sec:wybór}
Autor, biorąc pod uwagę wymienione zalety i~wady, koszty oraz przeprowadzone testy, zdecydował się podjąć rozwiązania problemu inżynierskiego przy użyciu platformy mikrokontrolera bez zainstalowanego systemu operacyjnego -- metodą baremetal programming. Wybrał do tego celu płytkę prototypową STM32F446RE, zawierającą wszystkie niezbędne do realizacji projektu komponenty. Autor motywuje swoją decyzję faktem, iż ta platforma daje dużą swobodę w~projektowaniu rozwiązań i~dostarcza kompletny, darmowy ekosystem programistyczny, pozwalający na szybkie i~łatwe konfigurowanie oraz programowanie tego sprzętu. Dodatkowo, mikrokontroler bez systemu operacyjnego gwarantuje, iż wykonywane będzie tylko to, co konstruktor zaprogramuje. Pozwala to uniknąć narzutów czasowych powstałych od zadań pobocznych i~zostawia programistę z~mniejszą liczbą czynników, które trzeba rozważyć podczas implementowania programu.
\subsection{Odpowiedni dobór środowiska programistycznego}
\label{sec:IDE}
Jak już zostało wspomniane w~poprzedniej sekcji, STMicroelectronics dostarcza darmowe, kompletne środowisko programistyczne wspomagające pracę z~ich produktami.\\
Autor postanowił skorzystać z~następujących programów:
\begin{enumerate}
	\item STM32CubeMX\\ 
	Wybór płytki prototypowej lub samego mikrokontrolera, uruchamianie/wyłączanie komponentów oraz kompletna konfiguracja. Interfejs graficzny aplikacji ułatwia przypisanie pinów oraz skonfigurowanie peryferiów i~timerów.
	\item System Workbench for STM32\\
	Środowisko programistyczne zrealizowane na bazie Eclipse, stosowane jako samodzielny program lub jako plugin do wymienionego środowiska.
	\item STM32 ST-LINK Utility\\
	Program dostarczający interfejsu graficznego oraz tekstowego do badania pamięci mikrokontrolera, pozwala na podgląd wartości zmiennych w~czasie rzeczywistym. %TODO WRITE MORE
	\item STMStudio\\
	Środowisko komunikujące się w~czasie rzeczywistym z~mikrokontrolerem za pomocą obecnego na płytce debuggera/programatora ST-Link. Pozwala na podgląd wartości zmiennych w~czasie rzeczywistym oraz wizualizację danych. %TODO WRITE MORE
\end{enumerate}	